Строка - это упорядоченная последовательность символов. Можно даже 
сказать, что строка - это массив символов, поскольку массив - это и есть 
упорядоченная последовательность. 
Строки поддерживают обращение по индексу, конкатенацию ( + ), повторение(*), проверку на вхождение (in).

Неизменяемые типы (числа, строки, кортежи, фиксированные множества)
Типы объектов в категории неизменяемых не поддерживают модификацию на
месте, но мы всегда можем выполнять выражения для создания новых объектов
и присваивать их результаты переменным по мере надобности.


####Символы, представляемые в строке посредством обратной косой черты
Управляющая последовательность Описание
```
\ новая строка Игнорируется (строка продолжения)
\\ Обратная косая черта (сохраняет один символ \)
\’ Одинарная кавычка (сохраняет ’)
\" Двойная кавычка (сохраняет ”)
\а Звонок
\ь Забой
\f Перевод страницы
\п Новая строка (перевод строки)
\г Возврат каретки
\t Горизонтальная табуляция
\v Вертикальная табуляция
\xhh Символ с шестнадцатеричным значением hh
(точно 2 цифры)
\ооо Символ с восьмеричным значением ооо
(до 3 цифр)
\0 Пустой: двоичный символ 0 (не конец строки)
\U { идентификатор } Идентификатор базы данных Unicode
\uhhhh Символ Unicode с 16-битным шестнадцатеричным
значением
\Uhhhhhhh Символ Unicode с 32-битным шестнадцатеричным
значением3
\остальное Не управляющая последовательность
(сохраняет \ и остальное)
```

####Распространенные строковые литералы и операции
```
Операция Описание
S = ’ ’ Пустая строка
S = "spam’s" Двойные кавычки; то же самое, что и одинарные
S = 's\np\ta\x00m’ Управляющие последовательности
S = " " " .. .много строк. . . " Блочные строки в утроенных кавычках
S = г’\temp\spam’ Неформатированные строки (без управляющих символов)
В = b’sp\xc4m' Байтовые строки в Python 2.6, 2.7 и З.Х (см. главы 4 и 37)
U = u’sp\u00c4m' Строки Unicode в Python 2.Х и 3.3+ (см. главы 4 и 37)
SI + S2
S*3
Конкатенация, повторение
S[i]
S[i:j]
len (S)
Индекс, срез, длина
"a %s parrot" % kind Выражение форматирования строки
"a {0} parrot"
.format(kind)S.find(’pa’)
```


***
Mетоды — это просто функции, которые ассоциированы с определенными объектами и действуют на них. Формально они являются
атрибутами, прикрепленными к объектам, которые ссылаются на вызываемые функции, всегда имеющие в своем распоряжении подразумеваемый объект. Говоря точнее,
функции представляют собой пакеты кода, а вызовы методов комбинируют две операции — извлечение атрибута и вызов.
Извлечения атрибутов
Выражение в форме объект, атрибут означает “извлечь значение атрибута в
объекте”.
Выражения вызовов
Выражение в форме функция (аргументы) означает “вызвать код функции,
передав ему ноль или большее количество разделенных запятыми объектов
аргументов, и возвратить результирующее значение функции".
Объединение двух операций вместе позволяет вызвать метод объекта. Выражение
вызова метода:
объект. метод (аргументы)
оценивается слева направо — Python сначала извлечет метод из объекта и затем вызовет его, передавая объект и аргументы. Или простыми словами выражение вызова
метода означает следующее:
Вызвать метод для обработки объекта с аргументами.
```
S.capitalize()
S.casefold()
S.center(width [, fill])
S.count(sub [, start [, end]])
S.encode([encoding [,errors]])
S.endswith(suffix [r start [, end]])
S.expandtabs([tabsize])
S.find(sub [, start [, end]])
S.format(fmtstr, *args, **kwargs)
S.index(sub [, start [, end]])
S.isalnum()
S.isalpha()
S.isdecimal()
S.isdigit()
S.isidentifier()
S.islower()
S.isnumeric()
S.isprintable()
S.isspace()
S.istitle()
S.isupper()
S.join(iterable)
S.1just(width [, fill])
S.lower()
S.lstrip([chars])
S.maketrans (x [, y[, z] ] )
S.partition(sep)
S.replace(old, new [, count])
S.rfind(sub [,start [,end]])
S.rindex(sub [, start [, end]])
S.rjust(width [, fill])
S.rpartition(sep)
S.rsplit([sep[, maxsplit]])
S.rstrip([chars])
S.split([sep [,maxsplit]])
S.splitlines([keepends])
S.startswith(prefix [, start [, end]])
S.strip([chars])
S.swapcase()
S.title()
S.translate(map)
S.upper()
S.zfill(width)
```
####Перевотрот строки задом наперед

 С помощью цикла `for`` нам не надо в ручную задавать условия окончания цикла

```
s = 'spartak moskow'
for i in s[::-1]:
    print(i,end='')

>>> woksom katraps
 
 С помощью цикла while
s = 'spartak moskow'
i = len(s) - 1
while i >= 0:
    print(s[i],end='')
    i -= 1
>>> woksom katraps
```
***
###ПОИСК ПО ШАБЛОНУ 
Довольно часто на практике возникает необходимость найти текст, соответствующий определенному шаблону. Если искомый текст является простым 
литералом, чаще проще использовать базовые строковые методы, напрbмер, strfind(), str.endswith(), str.startswith() и т.п. Например:
```
>>> text = 'yeah, but no, but yeah, but no, but yeah' 
>>>#Точное совпадение 
>>> text = 'yeah' 
False 
>>>#Совпадение в начале или в конце 
>>> text. startswi th ( 'yeah') 
True 
>>> text. endswi th ( 'no' ) 
False 
>>>#Поиск позиции первого вхождения искомого текста в строку 
>>> text.find( 'no') 
10 
>>
```

####СОВПАДЕНИЕ ТЕКСТА В НАЧАЛЕ И КОНЦЕ СТРОКИ 
Пример показывает, как произвести поиск в начале и конце строки определенного шаблона текста, например, расширение имени файла, название 
протокола и т.д. 
Самый простой способ заключается в использовании методов str.startswith() 
и str.endswith(). Например:
```
>>> filename = 'spam.txt' 
>>> filename. endswi th (' . txt') 
True 
>>> filename. startswi th ( 'file: ' ) 
False 
>>> url = 'http://www.python.org' 
>>> url. startswi th ( 'http: ') 
True 
>>>
```
Если вам нужно проверить на соответствие нескольким вариантам, просто предоставьте кортеж возможных вариантов функциям startswith() или endswith(): 
```
>>> import os 
>>> filenames = os.listdir('. ') 
>>> filenames 
[ 'Makefile', 'foo.c', 'bar.py', 'spam.c', 'spam.h' ] 
>>> [name for name in filenames if name.endswith((' .с', '.h')) 
] 
[ 'foo. с', 'spam. с', 'spam. h' 
>>> any (name. endswi th ( ' . ру' ) for name in filenames) 
True 
>>> 
```
####Форматирование строк методом `fomat`
```
first_n = 'Ivanov'
second_n = 'Dima'
greeting = "Здравствуйте, {sn} {fn}!".format(fn = first_n,sn = second_n)
>>>Здраствуйте, Ivanov Dima

nnum = int(input())
next_num = num + 1
pred_num = num -1
text = """Для числа {0} предыдущим будет число {1}.
Для числа {0} следующим будет число {2}.""".format(num,pred_num,next_num)
>>>Для числа 99 предыдущим будет число 98.
   Для числа 99 следующим будет число 100.
